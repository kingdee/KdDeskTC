use crate::log;
use directories_next::ProjectDirs;
use rand::Rng;
use serde_derive::{Deserialize, Serialize};
use sodiumoxide::crypto::sign;
use std::{
    collections::HashMap,
    fs,
    net::{IpAddr, Ipv4Addr, SocketAddr},
    path::{Path, PathBuf},
    sync::{Arc, Mutex, RwLock},
    time::SystemTime,
};

pub const APP_NAME: &str = "KdDeskTC";
// added by fantacy.
//pub const APP_NAME_CN: &str = "金蝶云.远程办公助手-远程协助V2.0.2";
pub const APP_NAME_CN: &str = "金蝶.远程协助";
pub const RENDEZVOUS_TIMEOUT: u64 = 12_000;
pub const CONNECT_TIMEOUT: u64 = 18_000;
pub const REG_INTERVAL: i64 = 12_000;
pub const COMPRESS_LEVEL: i32 = 3;
const SERIAL: i32 = 1;
// 128x128
// #[cfg(target_os = "macos")] // 128x128 on 160x160 canvas, then shrink to 128, mac looks better with padding
// pub const ICON: &str = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAAAyVBMVEUAAAAAcf8Acf8Acf8Acv8Acf8Acf8Acf8Acf8AcP8Acf8Ab/8AcP8Acf////8AaP/z+f/o8v/k7v/5/v/T5f8AYP/u9v/X6f+hx/+Kuv95pP8Aef/B1/+TwP9xoP8BdP/g6P+Irv9ZmP8Bgf/E3f98q/9sn/+01f+Es/9nm/9Jif8hhv8off/M4P+syP+avP86iP/c7f+xy/9yqf9Om/9hk/9Rjv+60P99tv9fpf88lv8yjf8Tgf8deP+kvP8BiP8NeP8hkP80gP8oj2VLAAAADXRSTlMA7o7qLvnaxZ1FOxYPjH9HWgAABHJJREFUeNrtm+tW4jAQgBfwuu7MtIUWsOUiCCioIIgLiqvr+z/UHq/LJKVkmwTcc/r9E2nzlU4mSTP9lpGRkZGR8VX5cZjfL+yCEXYL+/nDH//U/Pd8DgyTy39Xbv7oIAcWyB0cqbW/sweW2NtRaj8H1sgpGOwUIAH7Bkd7YJW9dXFwAJY5WNP/cmCZQnJvzIN18on5LwfWySXlxEPYAIcad8D6PdiHDbCfIFCADVBIENiFDbCbIACKPPXrZ+cP8E6/0znvP4EymgIEravIRcTxu8HxNSJ60a8W0AYECKrlAN+YwAthCd9wm1Ug6wKzIn5SgRduXfwkqDasCjx0XFzi9PV6zwNcIuhcWBOg+ikySq8C9UD4dEKWBCoOcspvAuLHTo9sCDQiFPHotRM48j8G5gVur1FdAN2uaYEuiz7xFsgEJ2RUoMUakXuBTHHoGxQYOBhHjeUBAefEnMAowFhaLBOKuOemBBbxLRQrH2PBCgMvNCPQGMeevTb9zLrPxz2Mo+QbEaijzPUcOOHMQZkKGRAIPem39+bypREMPTkQW/oCfk866zAkiIFG4yIKRE/aAnfiSd0WrORY6pFdXQEqi9mvAQm0RIOSnoCcZ8vJoz3diCnjRk+g8VP4/fuQDJ2Lxr6WwG0gXs9aTpDzW0vgDBlVUpixR8gYk44AD8FrUKHr8JQJGgIDnoDqoALxmWPQSi9AVVzm8gKUuEPGr/QCvptwJkbSYT/TC4S8C96DGjTj86aHtAI0x2WaBIq0eSYYpRa4EsdWVVwWu9O0Aj6f6dyBMnwEraeOgSYu0wZlauzA47QCbT7DgAQSE+hZWoEBF/BBmWOewNMK3BsSqKUW4MGcWqCSVmDkbvkXGKQOwg6PAUO9oL3xXhA20yaiCjuwYygRVQlUOTWTCf2SuNJTxeFjgaHByGuAIvd8ItdPLTDhS7IuqEE1YSKVOgbayLhSFQhMzYh8hwfBs1r7c505YVIQYEdNoKwxK06MJiyrpUFHiF0NAfCQUVHoiRclIXJIR6C2fqG37pBHvcWpgwzvAtYwkR5UGV2e42UISdBJETl3mg8ouo54Rcnti1/vaT+iuUQBt500Cgo4U10BeHSkk57FB0JjWkKRMWgLUA0lLodtImAQdaMiiri3+gIAPZQoutHNsgKF1aaDMhMyIdBf8Th+Bh8MTjGWCpl5Wv43tDmnF+IUVMrcZgRoiAxhtrloYizNkZaAnF5leglbNhj0wYCAbCDvGb0mP4nib7O7ZlcYQ2m1gPtIZgVgGNNMeaVAaWR+57TrqgtUnm3sHQ+kYeE6fufUubG1ez50FXbPnWgBlgSABmN3TTcsRl2yWkHRrwbiunvk/W2+Mg1hPZplPDeXRbZzStFH15s1QIVd3UImP5z/bHpeeQLvRJ7XLFUffQIlCvqlXETQbgN9/rlYABGosv+Vi9m2Xs639YLGrZd0br+odetlvdsvbN56abfd4vbCzv9Q3v/ygoOV21A4OPpfXvH4Ai+5ZGRkZGRkbJA/t/I0QMzoMiEAAAAASUVORK5CYII=
// ";

// 128x128 2022-10-09
#[cfg(target_os = "macos")]
pub const ICON: &str = "data:image/png;base64,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";

#[cfg(not(target_os = "macos"))] // 128x128 no padding
// modified by fantacy.
//pub const ICON: &str = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAAA7VBMVEUAAAAAcf8Acf8Acf8Adf8Acf8Acf8AcP8Acv8AcP8Acf8Acf8Acf8Acv8Acf8Acf8Ab/8AcP8Acf8Acf8Acf/////7/f8Dc/8TfP/1+f/n8v9Hmf/u9v+Uw//Q5f9hp/8Yfv8Qev8Ld/+52P+z1f+s0f81j/8wjP8Hdf/3+/8mh/8fg//x9//h7//H4P9xsP9rrf9oq/8rif/r9P/D3v+92/+Duv9bpP/d7f/U5/9NnP8/lP8jhP/L4v/B3P+OwP9+t/95tf9Rn/8bgf/Z6v+Zx/90sv9lqf85kf+hy/9UoP+Wxf+kzP+dyP+Lvv/H4q8IAAAAFHRSTlMA+u6bB6x5XR4V0+S4i4k5N+a81W8MiAQAAAVcSURBVHjazdvpWtpAGIbhgEutdW3fL2GHsMsiq4KI+66t5384XahF/GbizJAy3j/1Ah5CJhNCxpm1vbryLRrBfxKJrq+sbjtSa5u7WIDdzTVH5PNSBAsSWfrsMJ+iWKDoJ2fW8hIWbGl55vW/YuE2XhUsb8CCr9OCJVix9G//gyWf/o6/KCyJfrbwAfAPYS0CayK/j4mbsGjrV8AXWLTrONuwasdZhVWrzgqsWnG+wap1Jwqrok4EVkUcmKhdVvBaOVnzYEY/oJpMD4mo6ONF/ZSIUsX2FZjQA7xRqUET+y/v2W/Sy59u62DCDMgdJmhqgIk7eqWQBBNWwPhmj147w8QTzTjKVsGEEBBLuzSrhIkivTF8DD/Aa6forQNMHBD/VyXkgHGfuBN5ALln1TADOnESyGCiT8L/1kILqD6Q0BEm9kkofhdSwNUJiV1jQvZ/SnthBNSaJJGZbgGJUnX+gEqCZPpsJ2T2Y/MGVBrE8eOAvCA/X8A4QXLnmEhTgIPqPAG5IQU4fhmkFOT7HAFenwIU8Jd/TUEODQIUtu1eOj/dUD9cknOTpgEDkup3YrOfVStDUomcWcBVisTiNxVw3TPpgCl4RgFFybZ/9iHmn8uS2yYBA8m7qUEu9oOEejH9gHxC+PazCHbcFM8K+gGHJNAs4z2xgnAkVHQDcnG1IzvnCSfvom7AM3EZ9voah4+KXoAvGFJHMSgqEfegF3BBTKoOVfkMMXFfJ8AT7MuXUDeOE9PWCUiKBpKOlmAP1gngH2LChw7vhJgr9YD8Hnt0BxrE27CtHnDJR4AHTX1+KFAP4Ef0LHTxN9HwlAMSbAjmoavKZ8ayakDXYAhwN3wzqgZk2UPvwRjshmeqATeCT09f3mWnEqoBGf4NxAB/moRqADuOtmDiid6KqQVcsQeOYOKW3uqqBRwL5nITj/yrlFpAVrDpTJT5llQLaLMHwshY7UDgvD+VujDC96WWWsBtSAE5FnChFnAeUkDMdAvw88EqTNT5SYXpTlgPaRQM1AIGorkolNnoUS1gJHigCX48SaoF3Asuspg4Mz0U8+FTgIkCG01V09kwBQP8xG5ofD5AXeirkPEJSUlwSVIfP5ykVQNaggvz+k7prTvVgDKF8BnUXP4kqgEe/257E8Ig7EE1gA8g2stBTz7FLxqrB3SIeYaeQ2IG6gE5l2+Cmt5MGOfP4KsGiH8DOYWOoujnDY2ALHF3810goZFOQDVBTFx9Uj7eI6bp6QTgnLjeGGq6KeJuoRUQixN3pDYWyz1Rva8XIL5UPFQZCsmG3gV7R+dieS+Jd3iHLglce7oBuCOhp3zwHLxPQpfQDvBOSKjZqUIml3ZJ6AD6AajFSZJwewWR8ZPsEY26SQDaJOMeZP23w6bTJ6kBjAJQILm9hzqm7otu4G+nhgGxIQUlPLKzL7GhbxqAboMCuN2XXd+lAL0ajAMwclV+FD6jAPEy5ghAlhfwX2FODX445gHKxyN++fs64PUHmDMAbbYN2DlKk2QaScwdgMs4SZxMv4OJJSoIIQBl2Qtk3gk4qiOUANRPJQHB+0A6j5AC4J27QQEZ4eZPAsYBXFk0N/YD7iUrxRBqALxOTzoMC3x8lCFlfkMjuz8iLfk6fzQCQgjg8q3ZEd8RzUVuKelBh96Nzcc3qelL1V+2zfRv1xc56Ino3tpdPT7cd//MspfTrD/7R6p4W4O2qLMObfnyIHvvYcrPtkZjDybW7d/eb32Bg/UlHnYXuXz5CMt8rC90sr7Uy/5iN+vL/ewveLS/5NNKwcbyR1r2a3/h8wdY+v3L2tZC5oUvW2uO1M7qyvp/Xv6/48z4CTxjJEfyjEaMAAAAAElFTkSuQmCC
//";
//pub const ICON: &str = "data:image/png;base64,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
//";
pub const ICON: &str = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAA/1JREFUaEPlml1sVEUUgL9pt3/QP7DJUqi1BGI3aPpACk3EGPHnwRhreDBCCiSkKAkSlMQqPhlfDGKiaEwkosG/qCFG/kIJkRclFGMCIW0itKSFNoQCNWxrt9my27tjZrtbuvbuZm97rtmr83pnzjnfzDnn3jnnKjIMrXUN8DzwLLAMWAyUZloj8CwE3AB6gRPAUaXU9XRyld0DrbUx9B1gC5AvYNRcRFjAQeBtpZQBSxkzALTWzcC3QNlctLqwdhTYqJQ6Nl12CoDWeifwIZDnggESImPALqXUx0lhUwCJnT+cw8YnbTYQ65InEQdI+PzlHHSbdKdm3ClgYiIJcADYKnHG/6KMz5VSL6lEqrwmnW06By32nxuna3CCiRg0VPtobSpi9f0+KUaTneoMwCvAJ1JSjZyvz9/l3dNhJmI6NeUpxa7Hitn+SLGUuh0GoB14RkripdsW6w6OzjB+KmsoxXctpaySOYmTBqAbeFAKYOeRMdovRTKKW7O0gK/Wi7zQewyAiWgRacbqJ/b/xUDQuGf6UVGSx/nXKiT2LGQAUh11jmIb940wHDapOv0ozFd0tVWSb/sh48wAcYDN34fouBbNaMXDi3wc2SLzpSIO8GNnhN0nxjICvPXkPFpXFznb6jSzxQGMntZDIX7ptT+FlTU+fthYRp6A+xhdrgBEY/DRr2G++P0uUWsyxPLzFC0ri3hzbQlFYu+yOQCYMO0IQX8EGudDvY1HRCz445aFFdM8tMhHsaDhU++V2WShYQuae+HM6OTuKqVo88N7S0Tc2pGQWbnQtgH4bGhm9j26XNEskt6zZ5gVwOJOGIzOBNhapTjwQPbKJWb+PwE870J2Qfy6H/Z6JYiN75o0ejaZRudBQOwT31lkzCoGnKlwd7ZrAEHLYvfAAKeGh4lozdrycvbW1rKksFCUyBWAca1Z1dVFdzicYqy/oICLDQ3c55N7JbsCsO/mTd7o77fd6Verq3m/tlbsFFwBWH/lCj/duWNrZFNZGWdWrMhtgJf7+vhyaMjWyKcqKmgPBHIb4HAwyIs9PbZGflBXxw6/P7cB4peavj6++ccpPF1ZyfH6etHKsSsxkNxeEwenRkaIas3j5eVsqqpC6CI2dYKuAoj5SQZB/wkA0cKW010f/ROuXoD5C2BZo7neOZIQL2yJlhadqB8LwrE9EBmfXBV4FJpecCKBeGlRtLjrRH33Wfjt0L0VhSWwYY8TCcSLu+Ll9WxNuHEZfv703uyFNfBcW7ar4/Pi5XXTCxZvcGRrxoXj0N0BpQtgTQsszP5SNNngMIq01t5tMSUATGPbu02+BIRpcHuzzZr0V083uqdBePdXg2kQ3v3ZY3r688LvNn8DGq671Djfd1YAAAAASUVORK5CYII=";
#[cfg(target_os = "macos")]
pub const ORG: &str = "com.kingdee";

type Size = (i32, i32, i32, i32);

lazy_static::lazy_static! {
    static ref CONFIG: Arc<RwLock<Config>> = Arc::new(RwLock::new(Config::load()));
    static ref CONFIG2: Arc<RwLock<Config2>> = Arc::new(RwLock::new(Config2::load()));
    static ref LOCAL_CONFIG: Arc<RwLock<LocalConfig>> = Arc::new(RwLock::new(LocalConfig::load()));
    pub static ref ONLINE: Arc<Mutex<HashMap<String, i64>>> = Default::default();
}
#[cfg(any(target_os = "android", target_os = "ios"))]
lazy_static::lazy_static! {
    pub static ref APP_DIR: Arc<RwLock<String>> = Default::default();
}
const CHARS: &'static [char] = &[
    '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
    'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
];

/*pub const RENDEZVOUS_SERVERS: &'static [&'static str] = &[
    "rs-ny.rustdesk.com",
    "rs-sg.rustdesk.com",
    "rs-cn.rustdesk.com",
];*/
pub const RENDEZVOUS_SERVERS: &'static [&'static str] = &[
    "kdtc-gz.kingdee.com",
    "kdtc-bj.kingdee.com",
];

pub const TEST1: &'static str = "";
pub const TEST2: &'static str = "";
pub const TEST3: &'static str = "";
pub const TEST4: &'static str = "";

// added by fantacy.
pub const RENDEZVOUS_PORT: i32 = 21116;
pub const RELAY_PORT: i32 = 21117;

pub fn get_public_key() -> String {
    // &s[6..11]
    let test1 = TEST1.to_string();
    let test2 = TEST2.to_string();
    let test3 = TEST3.to_string();
    let test4 = TEST4.to_string();
    let key = format!("{}{}{}{}=",  &test1[1..], &test2[2..], &test3[3..], &test4[4..] );
    // println!("===public key {} ", key.clone());
    return key
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum NetworkType {
    Direct,
    ProxySocks,
}

#[derive(Debug, Default, Serialize, Deserialize, Clone, PartialEq)]
pub struct Config {
    #[serde(default)]
    id: String,
    #[serde(default)]
    password: String,
    #[serde(default)]
    salt: String,
    #[serde(default)]
    cstdir: String,
    #[serde(default)]
    pwdupd: String,
    #[serde(default)]
    idle: String,
    #[serde(default)]
    flagex: String,
    #[serde(default)]
    uid: String,
    #[serde(default)]
    key_pair: (Vec<u8>, Vec<u8>), // sk, pk
    #[serde(default)]
    key_confirmed: bool,
    #[serde(default)]
    keys_confirmed: HashMap<String, bool>,
}

#[derive(Debug, Default, PartialEq, Serialize, Deserialize, Clone)]
pub struct Socks5Server {
    #[serde(default)]
    pub proxy: String,
    #[serde(default)]
    pub username: String,
    #[serde(default)]
    pub password: String,
}

// more variable configs
#[derive(Debug, Default, Serialize, Deserialize, Clone, PartialEq)]
pub struct Config2 {
    #[serde(default)]
    rendezvous_server: String,
    #[serde(default)]
    nat_type: i32,
    #[serde(default)]
    serial: i32,

    #[serde(default)]
    socks: Option<Socks5Server>,

    // peer-file 权限
    #[serde(default)]
    pub permission: HashMap<String, String>,

    // the other scalar value must before this
    #[serde(default)]
    pub options: HashMap<String, String>,
}

#[derive(Debug, Default, Serialize, Deserialize, Clone)]
pub struct PeerConfig {
    #[serde(default)]
    pub password: Vec<u8>,
    #[serde(default)]
    pub size: Size,
    #[serde(default)]
    pub size_ft: Size,
    #[serde(default)]
    pub size_pf: Size,
    #[serde(default)]
    pub view_style: String, // original (default), scale
    #[serde(default)]
    pub image_quality: String,
    #[serde(default)]
    pub custom_image_quality: Vec<i32>,
    #[serde(default)]
    pub show_remote_cursor: bool,
    #[serde(default)]
    pub lock_after_session_end: bool,
    #[serde(default)]
    pub privacy_mode: bool,
    #[serde(default)]
    pub port_forwards: Vec<(i32, String, i32)>,
    #[serde(default)]
    pub direct_failures: i32,
    #[serde(default)]
    pub disable_audio: bool,
    #[serde(default)]
    pub disable_clipboard: bool,
    #[serde(default)]
    pub enable_file_transfer: bool,

    // the other scalar value must before this
    #[serde(default)]
    pub options: HashMap<String, String>,
    #[serde(default)]
    pub info: PeerInfoSerde,
}

#[derive(Debug, PartialEq, Default, Serialize, Deserialize, Clone)]
pub struct PeerInfoSerde {
    #[serde(default)]
    pub username: String,
    #[serde(default)]
    pub hostname: String,
    #[serde(default)]
    pub platform: String,
    // added by fantacy.
    #[serde(default)]
    pub uid: String,
}

fn patch(path: PathBuf) -> PathBuf {
    //println!("patch:{}.", path.display());
    if let Some(_tmp) = path.to_str() {
        #[cfg(windows)]
        return _tmp
            .replace(
                "system32\\config\\systemprofile",
                "ServiceProfiles\\LocalService",
            )
            .into();
        #[cfg(target_os = "macos")]
        return _tmp.replace("Application Support", "Preferences").into();
        #[cfg(target_os = "linux")]
        {
            if _tmp == "/root" {
                if let Ok(output) = std::process::Command::new("whoami").output() {
                    let user = String::from_utf8_lossy(&output.stdout)
                        .to_string()
                        .trim()
                        .to_owned();
                    if user != "root" {
                        return format!("/home/{}", user).into();
                    }
                }
            }
        }
    }
    path
}

impl Config2 {
    fn load() -> Config2 {
        Config::load_::<Config2>("2")
    }

    pub fn file() -> PathBuf {
        Config::file_("2")
    }

    fn store(&self) {
        Config::store_(self, "2");
    }

    pub fn get() -> Config2 {
        return CONFIG2.read().unwrap().clone();
    }

    pub fn set(cfg: Config2) {
        let mut lock = CONFIG2.write().unwrap();
        *lock = cfg;
        lock.store();
    }
}

impl Config {
    fn load_<T: serde::Serialize + serde::de::DeserializeOwned + Default + std::fmt::Debug>(
        suffix: &str,
    ) -> T {
        let file = Self::file_(suffix);
        log::debug!("Configuration path: {}", file.display());
        let cfg = match confy::load_path(&file) {
            Ok(config) => config,
            Err(err) => {
                log::error!("Failed to load config: {}", err);
                T::default()
            }
        };
        if suffix.is_empty() {
            log::debug!("{:?}", cfg);
        }
        cfg
    }

    fn store_<T: serde::Serialize>(config: &T, suffix: &str) {
        let file = Self::file_(suffix);
        if let Err(err) = confy::store_path(file, config) {
            log::error!("Failed to store config: {}", err);
        }
    }

    fn load() -> Config {
        Config::load_::<Config>("")
    }

    fn store(&self) {
        Config::store_(self, "");
    }

    pub fn file() -> PathBuf {
        Self::file_("")
    }

    pub fn import(from: &str) {
        log::info!("import {}", from);
        // load first to create path
        Self::load();
        crate::allow_err!(std::fs::copy(from, Self::file()));
        crate::allow_err!(std::fs::copy(
            from.replace(".toml", "2.toml"),
            Self::file_("2")
        ));
    }

    pub fn save_tmp() -> String {
        let _lock = CONFIG.read().unwrap(); // do not use let _, which will be dropped immediately
        let path = Self::file_("2").to_str().unwrap_or("").to_owned();
        let path2 = format!("{}_tmp", path);
        crate::allow_err!(std::fs::copy(&path, &path2));
        let path = Self::file().to_str().unwrap_or("").to_owned();
        let path2 = format!("{}_tmp", path);
        crate::allow_err!(std::fs::copy(&path, &path2));
        path2
    }

    fn file_(suffix: &str) -> PathBuf {
        let name = format!("{}{}", APP_NAME, suffix);
        Self::path(name).with_extension("toml")
    }

    pub fn get_home() -> PathBuf {
        #[cfg(any(target_os = "android", target_os = "ios"))]
        return Self::path("");
        if let Some(path) = dirs_next::home_dir() {
            patch(path)
        } else if let Ok(path) = std::env::current_dir() {
            path
        } else {
            std::env::temp_dir()
        }
    }

    pub fn path<P: AsRef<Path>>(p: P) -> PathBuf {
        #[cfg(any(target_os = "android", target_os = "ios"))]
        {
            let mut path: PathBuf = APP_DIR.read().unwrap().clone().into();
            path.push(p);
            return path;
        }
        #[cfg(not(target_os = "macos"))]
        let org = "";
        #[cfg(target_os = "macos")]
        let org = ORG;
        // /var/root for root
        if let Some(project) = ProjectDirs::from("", org, APP_NAME) {
            let mut path = patch(project.config_dir().to_path_buf());
            path.push(p);
            //println!("xxx path:{}.", path.display());
            return path;
        }
        return "".into();
    }

    #[allow(unreachable_code)]
    pub fn log_path() -> PathBuf {
        #[cfg(target_os = "macos")]
        {
            if let Some(path) = dirs_next::home_dir().as_mut() {
                path.push(format!("Library/Logs/{}", APP_NAME));
                return path.clone();
            }
        }
        #[cfg(target_os = "linux")]
        {
            let mut path = Self::get_home();
            path.push(format!(".local/share/logs/{}", APP_NAME));
            std::fs::create_dir_all(&path).ok();
            return path;
        }
        if let Some(path) = Self::path("").parent() {
            let mut path: PathBuf = path.into();
            path.push("log");
            return path;
        }
        "".into()
    }

    pub fn ipc_path(postfix: &str) -> String {
        #[cfg(windows)]
        {
            // \\ServerName\pipe\PipeName
            // where ServerName is either the name of a remote computer or a period, to specify the local computer.
            // https://docs.microsoft.com/en-us/windows/win32/ipc/pipe-names
            format!("\\\\.\\pipe\\{}\\query{}", APP_NAME, postfix)
        }
        #[cfg(not(windows))]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut path: PathBuf = format!("/tmp/{}", APP_NAME).into();
            fs::create_dir(&path).ok();
            fs::set_permissions(&path, fs::Permissions::from_mode(0o0777)).ok();
            path.push(format!("ipc{}", postfix));
            path.to_str().unwrap_or("").to_owned()
        }
    }

    pub fn icon_path() -> PathBuf {
        let mut path = Self::path("icons");
        if fs::create_dir_all(&path).is_err() {
            path = std::env::temp_dir();
        }
        path
    }

    #[inline]
    pub fn get_any_listen_addr() -> SocketAddr {
        SocketAddr::new(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)), 0)
    }

    pub fn get_rendezvous_server() -> String {
        // modified by fantacy.
        let mut rendezvous_server = Self::get_option("custom-rendezvous-server");
        if rendezvous_server.is_empty() {
            rendezvous_server = CONFIG2.write().unwrap().rendezvous_server.clone();
        }
        if rendezvous_server.is_empty() {
            rendezvous_server = Self::get_rendezvous_servers()
                .drain(..)
                .next()
                .unwrap_or("".to_owned());
        }
        if !rendezvous_server.contains(":") {
            rendezvous_server = format!("{}:{}", rendezvous_server, RENDEZVOUS_PORT);
        }
        rendezvous_server
    }

    pub fn get_rendezvous_servers() -> Vec<String> {
        // modified by fantacy.
        let s = Self::get_option("custom-rendezvous-server");
        if !s.is_empty() {
            return vec![s];
        }
        let serial_obsolute = CONFIG2.read().unwrap().serial > SERIAL;
        if serial_obsolute {
            let ss: Vec<String> = Self::get_option("rendezvous-servers")
                .split(",")
                .filter(|x| x.contains("."))
                .map(|x| x.to_owned())
                .collect();
            if !ss.is_empty() {
                return ss;
            }
        }
        return RENDEZVOUS_SERVERS.iter().map(|x| x.to_string()).collect();
    }

    pub fn reset_online() {
        *ONLINE.lock().unwrap() = Default::default();
    }

    pub fn update_latency(host: &str, latency: i64) {
        ONLINE.lock().unwrap().insert(host.to_owned(), latency);
        let mut host = "".to_owned();
        let mut delay = i64::MAX;
        for (tmp_host, tmp_delay) in ONLINE.lock().unwrap().iter() {
            if tmp_delay > &0 && tmp_delay < &delay {
                delay = tmp_delay.clone();
                host = tmp_host.to_string();
            }
        }
        if !host.is_empty() {
            let mut config = CONFIG2.write().unwrap();
            if host != config.rendezvous_server {
                log::debug!("Update rendezvous_server in config to {}", host);
                log::debug!("{:?}", *ONLINE.lock().unwrap());
                config.rendezvous_server = host;
                config.store();
            }
        }
    }

    pub fn set_id(id: &str) {
        let mut config = CONFIG.write().unwrap();
        if id == config.id {
            return;
        }
        config.id = id.into();
        config.store();
    }

    pub fn set_nat_type(nat_type: i32) {
        let mut config = CONFIG2.write().unwrap();
        if nat_type == config.nat_type {
            return;
        }
        config.nat_type = nat_type;
        config.store();
    }

    pub fn get_nat_type() -> i32 {
        CONFIG2.read().unwrap().nat_type
    }

    pub fn set_serial(serial: i32) {
        let mut config = CONFIG2.write().unwrap();
        if serial == config.serial {
            return;
        }
        config.serial = serial;
        config.store();
    }

    pub fn get_serial() -> i32 {
        std::cmp::max(CONFIG2.read().unwrap().serial, SERIAL)
    }

    fn get_auto_id() -> Option<String> {
        #[cfg(any(target_os = "android", target_os = "ios"))]
        return None;
        let mut id = 0u32;
        #[cfg(not(any(target_os = "android", target_os = "ios")))]
        if let Ok(Some(ma)) = mac_address::get_mac_address() {
            for x in &ma.bytes()[2..] {
                id = (id << 8) | (*x as u32);
            }
            id = id & 0x1FFFFFFF;
            Some(id.to_string())
        } else {
            None
        }
    }

    pub fn get_auto_password() -> String {
        let mut rng = rand::thread_rng();
        (0..6)
            .map(|_| CHARS[rng.gen::<usize>() % CHARS.len()])
            .collect()
    }

    pub fn get_key_confirmed() -> bool {
        CONFIG.read().unwrap().key_confirmed
    }

    pub fn set_key_confirmed(v: bool) {
        let mut config = CONFIG.write().unwrap();
        if config.key_confirmed == v {
            return;
        }
        config.key_confirmed = v;
        if !v {
            config.keys_confirmed = Default::default();
        }
        config.store();
    }

    pub fn get_host_key_confirmed(host: &str) -> bool {
        if let Some(true) = CONFIG.read().unwrap().keys_confirmed.get(host) {
            true
        } else {
            false
        }
    }

    pub fn set_host_key_confirmed(host: &str, v: bool) {
        if Self::get_host_key_confirmed(host) == v {
            return;
        }
        let mut config = CONFIG.write().unwrap();
        config.keys_confirmed.insert(host.to_owned(), v);
        config.store();
    }

    pub fn set_key_pair(pair: (Vec<u8>, Vec<u8>)) {
        let mut config = CONFIG.write().unwrap();
        if config.key_pair == pair {
            return;
        }
        config.key_pair = pair;
        config.store();
    }

    pub fn get_key_pair() -> (Vec<u8>, Vec<u8>) {
        // lock here to make sure no gen_keypair more than once
        let mut config = CONFIG.write().unwrap();
        if config.key_pair.0.is_empty() {
            let (pk, sk) = sign::gen_keypair();
            config.key_pair = (sk.0.to_vec(), pk.0.into());
            config.store();
        }
        config.key_pair.clone()
    }

    pub fn get_id() -> String {
        let mut id = CONFIG.read().unwrap().id.clone();
        if id.is_empty() {
            if let Some(tmp) = Config::get_auto_id() {
                id = tmp;
                Config::set_id(&id);
            }
        }
        id
    }

    pub fn get_options() -> HashMap<String, String> {
        CONFIG2.read().unwrap().options.clone()
    }

    pub fn set_options(v: HashMap<String, String>) {
        let mut config = CONFIG2.write().unwrap();
        if config.options == v {
            return;
        }
        config.options = v;
        config.store();
    }

    pub fn get_option(k: &str) -> String {
        if let Some(v) = CONFIG2.read().unwrap().options.get(k) {
            v.clone()
        } else {
            "".to_owned()
        }
    }

    pub fn set_option(k: String, v: String) {
        let mut config = CONFIG2.write().unwrap();
        let v2 = if v.is_empty() { None } else { Some(&v) };
        if v2 != config.options.get(&k) {
            if v2.is_none() {
                config.options.remove(&k);
            } else {
                config.options.insert(k, v);
            }
            config.store();
        }
    }

    fn get_permission(k: &str) -> String {
        if let Some(v) = CONFIG2.read().unwrap().permission.get(k) {
            v.clone()
        } else {
            "".to_owned()
        }
    }

    pub fn get_peer_permission(peer_id: String, permission_type: String) -> String {
        return Self::get_permission(format!("{}->{}", peer_id.to_string(), permission_type.to_string()).as_str())
    }

    fn set_permission(k: String, v: String) {
        let mut config = CONFIG2.write().unwrap();
        let v2 = if v.is_empty() { None } else { Some(&v) };
        if v2 != config.permission.get(&k) {
            if v2.is_none() {
                config.permission.remove(&k);
            } else {
                config.permission.insert(k, v);
            }
            config.store();
        }
    }

    pub fn set_peer_permission(peer_id: &str, permission_type: &str, val: bool) {
        let str_val = if val {
            "1".to_owned()
        } else {
            "0".to_owned()
        };
        Self::set_permission(format!("{}->{}", peer_id, permission_type), str_val)
    }

    pub fn update_id() {
        // to-do: how about if one ip register a lot of ids?
        let id = Self::get_id();
        let mut rng = rand::thread_rng();
        let new_id = rng.gen_range(1_000_000_000..2_000_000_000).to_string();
        Config::set_id(&new_id);
        log::info!("id updated from {} to {}", id, new_id);
    }

    pub fn set_password(password: &str) {
        let mut config = CONFIG.write().unwrap();
        if password == config.password {
            return;
        }
        config.password = password.into();
        config.store();
    }

    pub fn get_password() -> String {
        let mut password = CONFIG.read().unwrap().password.clone();
        if password.is_empty() {
            password = Config::get_auto_password();
            Config::set_password(&password);
        }
        password
    }

    // added by fantacy.
    pub fn set_cstdir(cstdir: &str) {
        let mut config = CONFIG.write().unwrap();
        if cstdir == config.cstdir {
            return;
        }
        config.cstdir = cstdir.into();
        config.store();
    }
    pub fn get_cstdir() -> String {
        let mut cstdir = CONFIG.read().unwrap().cstdir.clone();
        if cstdir.is_empty() {
        }
        cstdir
    }
    pub fn set_pwdupd(pwdupd: &str) {
        let mut config = CONFIG.write().unwrap();
        if pwdupd == config.pwdupd {
            return;
        }
        config.pwdupd = pwdupd.into();
        config.store();
    }
    pub fn get_pwdupd() -> String {
        let mut pwdupd = CONFIG.read().unwrap().pwdupd.clone();
        if pwdupd.is_empty() {
            pwdupd = "1".to_string().clone();
        }
        pwdupd
    }
    pub fn set_idle(idle: &str) {
        let mut config = CONFIG.write().unwrap();
        if idle == config.idle {
            return;
        }
        config.idle = idle.into();
        config.store();
    }
    pub fn get_idle() -> String {
        let mut idle = CONFIG.read().unwrap().idle.clone();
        if idle.is_empty() {
            idle = "1".to_string().clone();
        }
        idle
    }
    pub fn set_flagex(flagex: &str) {
        let mut config = CONFIG.write().unwrap();
        if flagex == config.flagex {
            return;
        }
        config.flagex = flagex.into();
        config.store();
    }
    pub fn get_flagex() -> String {
        let mut flagex = CONFIG.read().unwrap().flagex.clone();
        if flagex.is_empty() {
        }
        flagex
    }
    pub fn set_uid(uid: &str) {
        let mut config = CONFIG.write().unwrap();
        if uid == config.uid {
            return;
        }
        config.uid = uid.into();
        config.store();
    }
    pub fn get_uid() -> String {
        let mut uid = CONFIG.read().unwrap().uid.clone();
        if uid.is_empty() {
        }
        uid
    }

    pub fn set_salt(salt: &str) {
        let mut config = CONFIG.write().unwrap();
        if salt == config.salt {
            return;
        }
        config.salt = salt.into();
        config.store();
    }

    pub fn get_salt() -> String {
        let mut salt = CONFIG.read().unwrap().salt.clone();
        if salt.is_empty() {
            salt = Config::get_auto_password();
            Config::set_salt(&salt);
        }
        salt
    }

    pub fn set_socks(socks: Option<Socks5Server>) {
        let mut config = CONFIG2.write().unwrap();
        if config.socks == socks {
            return;
        }
        config.socks = socks;
        config.store();
    }

    pub fn get_socks() -> Option<Socks5Server> {
        CONFIG2.read().unwrap().socks.clone()
    }

    pub fn get_network_type() -> NetworkType {
        match &CONFIG2.read().unwrap().socks {
            None => NetworkType::Direct,
            Some(_) => NetworkType::ProxySocks,
        }
    }

    pub fn get() -> Config {
        return CONFIG.read().unwrap().clone();
    }

    pub fn set(cfg: Config) {
        let mut lock = CONFIG.write().unwrap();
        *lock = cfg;
        lock.store();
    }
}

const PEERS: &str = "peers";

impl PeerConfig {
    pub fn load(id: &str) -> PeerConfig {
        // let _ = CONFIG.read().unwrap(); // for lock
        match confy::load_path(&Self::path(id)) {
            Ok(config) => config,
            Err(err) => {
                log::error!("Failed to load config: {}", err);
                Default::default()
            }
        }
    }

    pub fn store(&self, id: &str) {
        // let _ = CONFIG.read().unwrap(); // for lock
        if let Err(err) = confy::store_path(Self::path(id), self) {
            log::error!("Failed to store config: {}", err);
        }
    }

    pub fn remove(id: &str) {
        fs::remove_file(&Self::path(id)).ok();
    }

    fn path(id: &str) -> PathBuf {
        let path: PathBuf = [PEERS, id].iter().collect();
        Config::path(path).with_extension("toml")
    }

    pub fn peers() -> Vec<(String, SystemTime, PeerConfig)> {
        if let Ok(peers) = Config::path(PEERS).read_dir() {
            if let Ok(peers) = peers
                .map(|res| res.map(|e| e.path()))
                .collect::<Result<Vec<_>, _>>()
            {
                // added by fantacy.
                let mut file = std::fs::File::create("history.ini").unwrap();
                use std::io::prelude::*;
                let mut idlst = String::new();

                let mut peers: Vec<_> = peers
                    .iter()
                    .filter(|p| {
                        p.is_file()
                            && p.extension().map(|p| p.to_str().unwrap_or("")) == Some("toml")
                    })
                    .map(|p| {
                        let t = crate::get_modified_time(&p);
                        let id = p
                            .file_stem()
                            .map(|p| p.to_str().unwrap_or(""))
                            .unwrap_or("")
                            .to_owned();
                        let c = PeerConfig::load(&id);

                        // added by fantacy.
                        if !idlst.is_empty() {
                            idlst.push(',');
                        }
                        idlst.push_str(&id);
                        file.write_all(format!("[{}]\r\nusername={}\r\nhostname={}\r\nplatform={}\r\nuid={}\r\n", id.to_string(), c.info.username.to_string(), c.info.hostname.to_string(), c.info.platform.to_string(), c.info.uid.to_string()).as_bytes());

                        if c.info.platform.is_empty() {
                            fs::remove_file(&p).ok();
                        }
                        (id, t, c)
                    })
                    .filter(|p| !p.2.info.platform.is_empty())
                    .collect();
                peers.sort_unstable_by(|a, b| b.1.cmp(&a.1));
                // added by fantacy.
                file.write_all(format!("[common]\r\nidlst={}\r\n", idlst.to_string()).as_bytes());
                file.sync_all();
                return peers;
            }
        }
        Default::default()
    }
}

#[derive(Debug, Default, Serialize, Deserialize, Clone)]
pub struct LocalConfig {
    #[serde(default)]
    remote_id: String, // latest used one
    #[serde(default)]
    size: Size,
    #[serde(default)]
    pub fav: Vec<String>,
    #[serde(default)]
    options: HashMap<String, String>,
}

impl LocalConfig {
    fn load() -> LocalConfig {
        Config::load_::<LocalConfig>("_local")
    }

    fn store(&self) {
        Config::store_(self, "_local");
    }

    pub fn get_size() -> Size {
        LOCAL_CONFIG.read().unwrap().size
    }

    pub fn set_size(x: i32, y: i32, w: i32, h: i32) {
        let mut config = LOCAL_CONFIG.write().unwrap();
        let size = (x, y, w, h);
        if size == config.size || size.2 < 300 || size.3 < 300 {
            return;
        }
        config.size = size;
        config.store();
    }

    pub fn set_remote_id(remote_id: &str) {
        let mut config = LOCAL_CONFIG.write().unwrap();
        if remote_id == config.remote_id {
            return;
        }
        config.remote_id = remote_id.into();
        config.store();
    }

    pub fn get_remote_id() -> String {
        LOCAL_CONFIG.read().unwrap().remote_id.clone()
    }

    pub fn set_fav(fav: Vec<String>) {
        let mut lock = LOCAL_CONFIG.write().unwrap();
        if lock.fav == fav {
            return;
        }
        lock.fav = fav;
        lock.store();
    }

    pub fn get_fav() -> Vec<String> {
        LOCAL_CONFIG.read().unwrap().fav.clone()
    }

    pub fn get_option(k: &str) -> String {
        if let Some(v) = LOCAL_CONFIG.read().unwrap().options.get(k) {
            v.clone()
        } else {
            "".to_owned()
        }
    }

    pub fn set_option(k: String, v: String) {
        let mut config = LOCAL_CONFIG.write().unwrap();
        let v2 = if v.is_empty() { None } else { Some(&v) };
        if v2 != config.options.get(&k) {
            if v2.is_none() {
                config.options.remove(&k);
            } else {
                config.options.insert(k, v);
            }
            config.store();
        }
    }
}

#[derive(Debug, Default, Serialize, Deserialize, Clone)]
pub struct LanPeers {
    #[serde(default)]
    pub peers: String,
}

impl LanPeers {
    pub fn load() -> LanPeers {
        // let _ = CONFIG.read().unwrap(); // for lock
        match confy::load_path(&Config::file_("_lan_peers")) {
            Ok(peers) => peers,
            Err(err) => {
                log::error!("Failed to load lan peers: {:?}", err);
                Default::default()
            }
        }
    }

    pub fn store(peers: String) {
        let f = LanPeers { peers };
        if let Err(err) = confy::store_path(Config::file_("_lan_peers"), f) {
            log::error!("Failed to store lan peers: {}", err);
        }
    }

    pub fn modify_time() -> crate::ResultType<u64> {
        let p = Config::file_("_lan_peers");
        Ok(fs::metadata(p)?
            .modified()?
            .duration_since(SystemTime::UNIX_EPOCH)?
            .as_millis() as _)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_serialize() {
        let cfg: Config = Default::default();
        let res = toml::to_string_pretty(&cfg);
        assert!(res.is_ok());
        let cfg: PeerConfig = Default::default();
        let res = toml::to_string_pretty(&cfg);
        assert!(res.is_ok());
    }
}
